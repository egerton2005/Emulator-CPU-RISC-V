# Test status in Github.Actions: [![statusbadge](../../actions/workflows/classroom.yml/badge.svg?branch=main&event=workflow_dispatch)](../../actions/workflows/classroom.yml)

> [!IMPORTANT]
> Чтобы GitHub Workflow отработал верно:
> * файл `task.bin` должен располагаться в корне репозитория.
> * файл с [функцией `main`](https://en.cppreference.com/w/c/language/main_function) должен располагаться в корне репозитория. Если работа выполняется на `C++`, то файл, содержащий функцию `main` должен называться `main.cpp`. Иначе – `main.c`.

Необходимо смоделировать работу системы “процессор-кэш-память” при выполнении кода на RISC-V с политиками вытеснения LRU и bit-pLRU.
Аргументы программе передаются через командную строку и могут располагаться в любом порядке относительно друг друга.

Вывод результата моделирования (число попаданий к общему числу обращений в процентах) производится в поток вывода в формате printf. Кроме общего процента попадания необходимо вычислить процент попадания отдельно для инструкций и для данных.

В случае, когда не было обращений к памяти, следует выводить nan%

# Входной файл

Двоичный файл в формате:
| Первые 32*4 байта | состояние регистров: pc, x1, …, x31 |
|-------------------|-------------------------------------|
|Фрагменты оперативной памяти в формате | 4 байта – адрес начала <br>4 байта – размер данного фрагмента N <br>N байт – фрагмент оперативной памяти |

Состояние памяти вне поданных фрагментов неопределено.

Необходимо поддерживать команды RV32I и RV32M.

# Выходной файл
Аналогичен входному, но содержит только 1 фрагмент памяти.

# Исполнение команд
Команды исполняются последовательно и читаются из памяти только перед непосредственным исполнением одной операцией чтения.

Концом исполнения кода программы считается переход на адрес, содержащийся в регистре ra на старте программы.

Гарантируется, что в памяти команды и данные не пересекаются (например, команда записи в память не изменит исходные команды).

Многобайтовое обращение считается за одну операцию. Гарантируется, что все обращения к памяти выровненные (адрес начала кратен размеру порции данных).

Команды ecall и ebreak приводят к завершению исполнения. 

# Кэш-память

Моделируемый кэш общий для данных и команд. По реализации должно быть однозначно понятно, что кэш реализован нужной конфигурации!

Начальное состояние – кэш пуст (все кэш-линии в состоянии invalid).

Переменные/константы (как они должны называться в коде):

MEMORY_SIZE – размер памяти (в байтах)

CACHE_SIZE – размер кэша без учёта служебной информации (в байтах)

CACHE_LINE_SIZE – размер кэш-линии (в байтах)

CACHE_LINE_COUNT – кол-во кэш-линий

CACHE_WAY – ассоциативность

CACHE_SET_COUNT –  кол-во блоков кэш-линий

ADDRESS_LEN – длина адреса (в битах)

CACHE_TAG_LEN –  длина тэга адреса (в битах)

CACHE_INDEX_LEN – длина индекса блока кэш-линий  (в битах)

CACHE_OFFSET_LEN – длина смещения внутри кэш-линии (в битах)

# task.bin
Помимо программы в репозиторий необходимо загрузить task.bin, который будет содержать такое состояние памяти и регистров, при котором в результате исполнения:

1. произойдёт хотя бы одно вытеснение из кэша;
2. для хотя бы одной из политик вытеснения будут достигнуты проценты (проценты представлены в таблице курса на листе ЛР3).
3. Будет полезным приложить в репозиторий task.asm/s, в котором вы опишите на ассемблере RISC-V тот код, который лежит в вашем task.bin. Так будет проще дать вам информативную обратную связь при возникновении проблем.
4. В автотестах будет производиться запуск с вашим task.bin файлом.
